<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jelly: Example3_Housekeeping.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Jelly
   </div>
   <div id="projectbrief">C++ embeddable database system for online games.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Example3_Housekeeping.cpp</div></div>
</div><!--header-->
<div class="contents">
<p>Illustrates how to do housekeeping operations.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;jelly/API.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(</div>
<div class="line">    <span class="keywordtype">int</span>     <span class="comment">/*aNumArgs*/</span>,</div>
<div class="line">    <span class="keywordtype">char</span>**  <span class="comment">/*aArgs*/</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Again, we&#39;ll need a host.</span></div>
<div class="line">    <a id="_a0" name="_a0"></a><a class="code hl_class" href="classjelly_1_1DefaultHost.html">jelly::DefaultHost</a> host(</div>
<div class="line">        <span class="stringliteral">&quot;.&quot;</span>,                                    <span class="comment">// Put database files here.</span></div>
<div class="line">        <span class="stringliteral">&quot;example3&quot;</span>,                             <span class="comment">// Database files will be prefixed with this.</span></div>
<div class="line">        NULL);                                  <span class="comment">// Use default configuration.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make sure the database is gone.</span></div>
<div class="line">    host.<a id="a1" name="a1"></a><a class="code hl_function" href="classjelly_1_1DefaultHost.html#ab1de3ff7219ffbd3c3b475028b874ff8">DeleteAllFiles</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// In this example we&#39;ll use a blob node, but in terms of housekeeping you&#39;ll see that </span></div>
<div class="line">    <span class="comment">// both kinds of nodes work exactly the same way.</span></div>
<div class="line">    <span class="keyword">typedef</span> <a id="_a2" name="_a2"></a><a class="code hl_class" href="classjelly_1_1BlobNode.html">jelly::BlobNode</a></div>
<div class="line">    &lt;</div>
<div class="line">        <a id="_a3" name="_a3"></a><a class="code hl_struct" href="structjelly_1_1UIntKey.html">jelly::UIntKey&lt;uint32_t&gt;</a>                <span class="comment">// Our blob keys will be uint32_t.</span></div>
<div class="line">    &gt; BlobNodeType;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create our blob node.</span></div>
<div class="line">    BlobNodeType blobNode(</div>
<div class="line">        &amp;host,                                  <span class="comment">// Associate the node with this host.</span></div>
<div class="line">        3);                                     <span class="comment">// Use globally unique node id 3.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Define a blob.</span></div>
<div class="line">    <a id="_a4" name="_a4"></a><a class="code hl_class" href="classjelly_1_1Buffer.html">jelly::Blob</a> blob;</div>
<div class="line"> </div>
<div class="line">    {</div>
<div class="line">        blob.<a id="a5" name="a5"></a><a class="code hl_function" href="classjelly_1_1Buffer.html#a160505d05d5ed2e7c4821610a15cfb7d">SetSize</a>(5);</div>
<div class="line">        memcpy(blob.<a id="a6" name="a6"></a><a class="code hl_function" href="classjelly_1_1Buffer.html#ae3566191507bbb63b45cc764dba094b6">GetPointer</a>(), <span class="stringliteral">&quot;hello&quot;</span>, 5);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Right, let&#39;s start off by saving this blob a bunch of times under the same key. </span></div>
<div class="line">    <span class="comment">// Imagine that this is a blob that contains the savegame of a player, saved at </span></div>
<div class="line">    <span class="comment">// a regular interval or when something has changed.</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t NUM_SAVES = 2000;</div>
<div class="line">    BlobNodeType::Request reqs[NUM_SAVES];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; NUM_SAVES; i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Define the request</span></div>
<div class="line">        reqs[i].SetKey(123);</div>
<div class="line">        reqs[i].SetSeq(1 + i);                  <span class="comment">// Incrementing sequence numbers.</span></div>
<div class="line">        reqs[i].SetBlob(blob.<a id="a7" name="a7"></a><a class="code hl_function" href="classjelly_1_1Buffer.html#a7f727fc78db1c4463ac8a40d6ce8102d">Copy</a>());           <span class="comment">// Copy blob and give ownership to </span></div>
<div class="line">                                                <span class="comment">// request.</span></div>
<div class="line">        <span class="comment">// Submit a set request</span></div>
<div class="line">        blobNode.Set(&amp;reqs[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Process all the requests.</span></div>
<div class="line">    blobNode.ProcessRequests();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Flush them all to disk. Note that this time we&#39;re flushing thousands of requests</span></div>
<div class="line">    <span class="comment">// at the same time. In general that&#39;s what we need to do: we shouldn&#39;t flush</span></div>
<div class="line">    <span class="comment">// individual requests, we need to batch as many as possible at the same time.</span></div>
<div class="line">    <span class="comment">// This is much more efficient. </span></div>
<div class="line">    blobNode.FlushPendingWAL();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// All the requests have now been flushed to disk and flagged as completed.</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; NUM_SAVES; i++)</div>
<div class="line">    {</div>
<div class="line">        JELLY_ASSERT(reqs[i].IsCompleted());</div>
<div class="line">        JELLY_ASSERT(reqs[i].GetResult() == <a id="a8" name="a8"></a>jelly::REQUEST_RESULT_OK);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If you look at your file system at this point, you&#39;ll find that there is </span></div>
<div class="line">    <span class="comment">// just a WAL file. If we just continued to make more set requests, these will </span></div>
<div class="line">    <span class="comment">// be appended to the WAL, which will grow and grow forever.</span></div>
<div class="line">    <span class="comment">// Obviously, this is not something we want. In this example we only have 1 key,</span></div>
<div class="line">    <span class="comment">// but on disk (in the WAL) we have thousands of copies of the blob associated </span></div>
<div class="line">    <span class="comment">// with it. We only care about the latest version of the blob, the one with the</span></div>
<div class="line">    <span class="comment">// highest sequence number.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The &quot;pending store&quot; is the set of all items (in this case blobs) that currently</span></div>
<div class="line">    <span class="comment">// have a write in the WAL. In this particular case, the pending store is just a </span></div>
<div class="line">    <span class="comment">// single item (blob key 123), but it has thousands of &quot;WAL instances&quot;. Every item</span></div>
<div class="line">    <span class="comment">// in the pending store holds a reference to the WAL where the highest sequence </span></div>
<div class="line">    <span class="comment">// number instance is written. </span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// What we need to do now is to flush the pending store to disk. </span></div>
<div class="line">    blobNode.FlushPendingStore();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now you&#39;ll see another file on disk, a &quot;store&quot;. This particular store contains </span></div>
<div class="line">    <span class="comment">// just a single item, but because the &quot;pending store&quot; is now empty, no items hold</span></div>
<div class="line">    <span class="comment">// any references to any WALs at this point. The single WAL we have has a </span></div>
<div class="line">    <span class="comment">// reference count of zero.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// WALs with no references (i.e. they don&#39;t hold the latest sequence number of</span></div>
<div class="line">    <span class="comment">// any pending store items) can be cleaned up (removed). Let&#39;s try that.</span></div>
<div class="line">    blobNode.CleanupWALs();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// What? We still have our WAL! Yes we do. That&#39;s because the WAL is still &quot;open&quot;,</span></div>
<div class="line">    <span class="comment">// meaning that this is the WAL any incoming requests will write their data to.</span></div>
<div class="line">    <span class="comment">// As soon as another request writes to it, its reference count will be </span></div>
<div class="line">    <span class="comment">// incremented again.</span></div>
<div class="line">    <span class="comment">// This WAL will continue to grow until it reaches a certain size (defaults to </span></div>
<div class="line">    <span class="comment">// 64 MB), at which point it will be closed and a new WAL will be created. </span></div>
<div class="line">    <span class="comment">// When it&#39;s closed and there are no references to it, it can be cleaned up.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &quot;Stores&quot; are immutable files stored on disk. Every time the pending store</span></div>
<div class="line">    <span class="comment">// is flushed it will create a new store file (provided the pending store wasn&#39;t</span></div>
<div class="line">    <span class="comment">// empty). You can&#39;t just flush pending store all the time, as it will create</span></div>
<div class="line">    <span class="comment">// large number of small files - but even if we&#39;re smart about when we call it,</span></div>
<div class="line">    <span class="comment">// we&#39;ll still see a growing number of store files. Even if we clean up WALs</span></div>
<div class="line">    <span class="comment">// regularly, disk space will still continue to grow.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This is where &quot;compaction&quot; comes into play. It will combine smaller stores </span></div>
<div class="line">    <span class="comment">// into bigger one, removing superflous copies of items in the process. </span></div>
<div class="line">    <span class="comment">// The latest store can never be compacted (because it might be in process of</span></div>
<div class="line">    <span class="comment">// writing), so we&#39;ll always need at least 3 stores.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let&#39;s make two more stores, so we can do a compaction.</span></div>
<div class="line">    <span class="keywordflow">for</span>(uint32_t i = 1; i &lt;= 2; i++)</div>
<div class="line">    {</div>
<div class="line">        BlobNodeType::Request req;</div>
<div class="line">        req.SetKey(123);            <span class="comment">// Still using the same key...</span></div>
<div class="line">        req.SetSeq(NUM_SAVES + i);  <span class="comment">// ... but with the highest sequence number.</span></div>
<div class="line">        req.SetBlob(blob.<a class="code hl_function" href="classjelly_1_1Buffer.html#a7f727fc78db1c4463ac8a40d6ce8102d">Copy</a>());   <span class="comment">// Set our test blob.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Submit, process, and flush to make another store.</span></div>
<div class="line">        blobNode.Set(&amp;req);</div>
<div class="line">        blobNode.ProcessRequests();</div>
<div class="line">        blobNode.FlushPendingWAL();</div>
<div class="line">        blobNode.FlushPendingStore();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now we have 3 stores. Each of them are identified with a &quot;store id&quot;, which</span></div>
<div class="line">    <span class="comment">// is an ever-increasing uint32_t. First store (store id 0) is the original one</span></div>
<div class="line">    <span class="comment">// while store id 1 and 2 contains the two new blobs we just flushed.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We&#39;ll now do a &quot;minor&quot; compaction of store ids 0 and 1. Minor compactions </span></div>
<div class="line">    <span class="comment">// take two or more specific stores and turn them into one. Major compactions </span></div>
<div class="line">    <span class="comment">// will compact all stores, but should be considered more of an off-line </span></div>
<div class="line">    <span class="comment">// process.</span></div>
<div class="line">    {</div>
<div class="line">        <a id="_a9" name="_a9"></a><a class="code hl_struct" href="structjelly_1_1CompactionJob.html">jelly::CompactionJob</a> compactionJob;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Tell the compaction process that the oldest store in disk is store id 0.</span></div>
<div class="line">        <span class="comment">// This information helps it decide which tombstones to prune (more on that</span></div>
<div class="line">        <span class="comment">// some other time).</span></div>
<div class="line">        compactionJob.<a id="a10" name="a10"></a><a class="code hl_variable" href="structjelly_1_1CompactionJob.html#ade4bfaf8236d39fac73f9c730011c901">m_oldestStoreId</a> = 0;  </div>
<div class="line"> </div>
<div class="line">        compactionJob.<a id="a11" name="a11"></a><a class="code hl_variable" href="structjelly_1_1CompactionJob.html#ade79e1ae339782c0c76d8268157f3a06">m_storeIds</a> = { 0, 1 };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Perform the minor compaction. Note that this can take a while and is a </span></div>
<div class="line">        <span class="comment">// blocking call (like everything else), but luckily you&#39;re free to call</span></div>
<div class="line">        <span class="comment">// this on another worker thread. You can have any number of minor</span></div>
<div class="line">        <span class="comment">// compactions happening at the same time, as long as the don&#39;t touch the </span></div>
<div class="line">        <span class="comment">// same stores.</span></div>
<div class="line">        std::unique_ptr&lt;BlobNodeType::CompactionResultType&gt; compactionResult(blobNode.PerformCompaction(compactionJob));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The compaction is completed, but it hasn&#39;t to be applied yet. The main</span></div>
<div class="line">        <span class="comment">// implication of this is that store id 0 and 1 still exists on disk.</span></div>
<div class="line">        <span class="comment">// So, let&#39;s apply the result:</span></div>
<div class="line">        blobNode.ApplyCompactionResult(compactionResult.get());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Now you&#39;ll see that we have two stores: store id 2 (unaffected by </span></div>
<div class="line">        <span class="comment">// compaction) and store id 3 (former store id 0 and 1 combined).</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// There is a lot of &quot;devil in the details&quot; about deciding when to perform these</span></div>
<div class="line">    <span class="comment">// various housekeeping tasks. If you do them too much it will negatively affect</span></div>
<div class="line">    <span class="comment">// performance, but if you do them too little, you&#39;ll end up with a lot of </span></div>
<div class="line">    <span class="comment">// superflous data on disk.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// A later example will be about the housekeeping advisor, which can help </span></div>
<div class="line">    <span class="comment">// monitoring your node and suggest when to perform various housekeeping tasks.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassjelly_1_1BlobNode_html"><div class="ttname"><a href="classjelly_1_1BlobNode.html">jelly::BlobNode</a></div><div class="ttdoc">A node for storing blobs.</div><div class="ttdef"><b>Definition</b> BlobNode.h:34</div></div>
<div class="ttc" id="aclassjelly_1_1Buffer_html"><div class="ttname"><a href="classjelly_1_1Buffer.html">jelly::Buffer</a></div><div class="ttdoc">Binary buffer object implementing the IBuffer interface.</div><div class="ttdef"><b>Definition</b> Buffer.h:21</div></div>
<div class="ttc" id="aclassjelly_1_1Buffer_html_a160505d05d5ed2e7c4821610a15cfb7d"><div class="ttname"><a href="classjelly_1_1Buffer.html#a160505d05d5ed2e7c4821610a15cfb7d">jelly::Buffer::SetSize</a></div><div class="ttdeci">void SetSize(size_t aSize) noexcept override</div><div class="ttdoc">Set size of buffer. Existing data is retained, but if new size is smaller than the previous one,...</div><div class="ttdef"><b>Definition</b> Buffer.h:111</div></div>
<div class="ttc" id="aclassjelly_1_1Buffer_html_a7f727fc78db1c4463ac8a40d6ce8102d"><div class="ttname"><a href="classjelly_1_1Buffer.html#a7f727fc78db1c4463ac8a40d6ce8102d">jelly::Buffer::Copy</a></div><div class="ttdeci">IBuffer * Copy() const noexcept override</div><div class="ttdoc">Make copy of buffer.</div><div class="ttdef"><b>Definition</b> Buffer.h:136</div></div>
<div class="ttc" id="aclassjelly_1_1Buffer_html_ae3566191507bbb63b45cc764dba094b6"><div class="ttname"><a href="classjelly_1_1Buffer.html#ae3566191507bbb63b45cc764dba094b6">jelly::Buffer::GetPointer</a></div><div class="ttdeci">const void * GetPointer() const noexcept override</div><div class="ttdoc">Get const pointer to data contained in buffer.</div><div class="ttdef"><b>Definition</b> Buffer.h:124</div></div>
<div class="ttc" id="aclassjelly_1_1DefaultHost_html"><div class="ttname"><a href="classjelly_1_1DefaultHost.html">jelly::DefaultHost</a></div><div class="ttdoc">Default implementation of the IHost interface, which nodes use to interact with the system.</div><div class="ttdef"><b>Definition</b> DefaultHost.h:20</div></div>
<div class="ttc" id="aclassjelly_1_1DefaultHost_html_ab1de3ff7219ffbd3c3b475028b874ff8"><div class="ttname"><a href="classjelly_1_1DefaultHost.html#ab1de3ff7219ffbd3c3b475028b874ff8">jelly::DefaultHost::DeleteAllFiles</a></div><div class="ttdeci">void DeleteAllFiles(uint32_t aNodeId=UINT32_MAX)</div><div class="ttdoc">Deletes all database files associated with specified node id.</div></div>
<div class="ttc" id="astructjelly_1_1CompactionJob_html"><div class="ttname"><a href="structjelly_1_1CompactionJob.html">jelly::CompactionJob</a></div><div class="ttdoc">Description of a minor compaction job (some stores turned into one).</div><div class="ttdef"><b>Definition</b> CompactionJob.h:16</div></div>
<div class="ttc" id="astructjelly_1_1CompactionJob_html_ade4bfaf8236d39fac73f9c730011c901"><div class="ttname"><a href="structjelly_1_1CompactionJob.html#ade4bfaf8236d39fac73f9c730011c901">jelly::CompactionJob::m_oldestStoreId</a></div><div class="ttdeci">uint32_t m_oldestStoreId</div><div class="ttdoc">Oldest store id currently present on disk.</div><div class="ttdef"><b>Definition</b> CompactionJob.h:58</div></div>
<div class="ttc" id="astructjelly_1_1CompactionJob_html_ade79e1ae339782c0c76d8268157f3a06"><div class="ttname"><a href="structjelly_1_1CompactionJob.html#ade79e1ae339782c0c76d8268157f3a06">jelly::CompactionJob::m_storeIds</a></div><div class="ttdeci">std::vector&lt; uint32_t &gt; m_storeIds</div><div class="ttdoc">Store ids to perform compaction on.</div><div class="ttdef"><b>Definition</b> CompactionJob.h:59</div></div>
<div class="ttc" id="astructjelly_1_1UIntKey_html"><div class="ttname"><a href="structjelly_1_1UIntKey.html">jelly::UIntKey</a></div><div class="ttdoc">Template for unsigned integer keys.</div><div class="ttdef"><b>Definition</b> UIntKey.h:13</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
